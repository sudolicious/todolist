name: $(Date:yyyyMMdd)-$(GitVersion.MajorMinorPatch)-$(Rev:.r)

trigger:
  branches:
    include:
      - main

pool: Default

variables:
  imageName: 'sudolicious1/todolist-backend'

resources:
  repositories:
    - repository: k8s
      type: git
      name: sudolicious/k8s
      ref: main
      endpoint: 'sudolicious'

stages:
# üîñ Get version using GitVersion
- stage: GetVersion
  displayName: 'üîñ Get Version'
  jobs:
  - job: GetVersionJob
    displayName: 'Get version with GitVersion'
    steps:
    - checkout: self
      fetchDepth: 0
      persistCredentials: true
      clean: true
      fetchTags: true

    # Calculate version using GitVersion tool
    - script: |
        VERSION=$(dotnet exec /home/olga/.dotnet/tools/.store/gitversion.tool/6.4.0/gitversion.tool/6.4.0/tools/net8.0/any/gitversion.dll /showvariable MajorMinorPatch)
        FULL_VERSION=$(dotnet exec /home/olga/.dotnet/tools/.store/gitversion.tool/6.4.0/gitversion.tool/6.4.0/tools/net8.0/any/gitversion.dll /showvariable FullSemVer)
        CURRENT_DATE=$(date +%Y%m%d)

        echo "##vso[build.updatebuildnumber]${CURRENT_DATE}-${VERSION}-$(Rev:r)"
        echo "##vso[task.setvariable variable=AppVersion;isOutput=true]$VERSION"
        
        echo "APP_VERSION=$VERSION" > version.env
        echo "FULL_VERSION=$FULL_VERSION" >> version.env
        echo "BUILD_DATE=$CURRENT_DATE" >> version.env
        
        echo "Detected AppVersion: $VERSION"
        echo "Detected FullVersion: $FULL_VERSION"
      name: setVersion
      displayName: 'Get version using GitVersion'

    # Publish version info as build artifact
    - publish: version.env
      artifact: version-info
      displayName: 'Publish version info'

# üîí Security scanning stage
- stage: SecurityScan
  displayName: 'üîí Security Scan'
  dependsOn: GetVersion
  jobs:
  - job: SecurityScan
    displayName: 'Basic Security Checks'
    steps:
    - checkout: self

    # Download version info from previous stage
    - download: current
      artifact: version-info
      displayName: 'Download version info'

    # Display version information
    - script: |
        source $(Pipeline.Workspace)/version-info/version.env
        echo "AppVersion: $APP_VERSION"
        echo "FullVersion: $FULL_VERSION"
      displayName: 'Display version info'

    # Run security scanning tools
    - script: |
        echo "Running security checks..."
        gosec -no-fail -exclude-dir=test_integration ./...
        go vet ./...
        go mod verify
        echo "‚úÖ Security scan completed"
      displayName: 'Run security scans'
      workingDirectory: backend

# üèóÔ∏è Build Docker image stage
- stage: Build
  displayName: 'üèóÔ∏è Build Docker Image'
  dependsOn: SecurityScan
  jobs:
  - job: Build
    displayName: 'Build image'
    steps:
    - checkout: self
    
    # Download version info artifact
    - download: current
      artifact: version-info
      displayName: 'Download version info'

    # Set Docker version variable from version info
    - script: |
        source $(Pipeline.Workspace)/version-info/version.env
        echo "##vso[task.setvariable variable=DockerAppVersion]$APP_VERSION"
        echo "Building version: $APP_VERSION"
      displayName: 'Set Docker version variable'

    # Login to Docker Hub using service connection
    - task: Docker@2
      inputs:
        command: 'login'
        containerRegistry: 'docker-hub-connection'
      displayName: 'Login to Docker Hub'
    
    # Build Docker image with version tags
    - task: Docker@2
      inputs:
        command: 'build'
        repository: '$(imageName)'
        dockerfile: 'backend/Dockerfile'
        buildContext: 'backend'
        tags: |
          $(DockerAppVersion)
          latest
        arguments: '--build-arg APP_VERSION=$(DockerAppVersion)'
      displayName: 'Build Docker image'

# üß™ Integration testing stage
- stage: IntegrationTest
  displayName: 'üß™ Integration Test'
  dependsOn: Build
  jobs:
  - job: TestBackend
    displayName: 'Integration Tests'
    steps:
    - checkout: self

    # Download version info for testing
    - download: current
      artifact: version-info
      displayName: 'Download version info'

    # Display version being tested
    - script: |
        source $(Pipeline.Workspace)/version-info/version.env
        echo "Testing version: $APP_VERSION"
      displayName: 'Display version'

    # Start PostgreSQL container for integration tests
    - script: |
        docker stop test-postgres 2>/dev/null || true
        docker rm test-postgres 2>/dev/null || true
        
        docker run --name test-postgres \
          -e POSTGRES_USER=$(dbUser) \
          -e POSTGRES_PASSWORD=$(dbPassword) \
          -e POSTGRES_DB=$(dbName) \
          -p $(dbPort):5432 \
          -d postgres:15
      displayName: 'Start PostgreSQL'

    # Wait for PostgreSQL to become ready
    - script: |
        for i in {1..20}; do
          if docker exec test-postgres pg_isready -U $(dbUser) 2>/dev/null; then
            echo "‚úÖ PostgreSQL is ready!"
            exit 0
          fi
          echo "Waiting for PostgreSQL... $i seconds"
          sleep 1
        done
        echo "‚ùå PostgreSQL startup failed"
        docker logs test-postgres || true
        exit 1
      displayName: 'Check PostgreSQL readiness'

    # Build and start the backend application
    - script: |
        go build -o todolist-app .
        DB_HOST=localhost DB_USER=$(dbUser) DB_PASSWORD=$(dbPassword) DB_NAME=$(dbName) DB_PORT=$(dbPort) DB_SSL_MODE=$(dbSslMode) ./todolist-app &
        APP_PID=$!
        echo $APP_PID > app.pid
        sleep 5
      displayName: 'Build and start backend'
      workingDirectory: backend

    # Run integration tests against the running application
    - script: |
        DB_HOST=localhost DB_USER=$(dbUser) DB_PASSWORD=$(dbPassword) DB_NAME=$(dbName) DB_PORT=$(dbPort) go test -v -tags=integration ./test_integration/ -timeout 30s
      displayName: 'Run health check test'
      workingDirectory: backend

    # Cleanup: stop application and PostgreSQL container
    - script: |
        kill $(cat app.pid) 2>/dev/null || true
        docker stop test-postgres 2>/dev/null || true
        docker rm test-postgres 2>/dev/null || true
      displayName: 'Cleanup'
      condition: always()
      workingDirectory: backend

# üöÄ Push to Docker Hub stage
- stage: Push
  displayName: 'üöÄ Push to Docker Hub'
  dependsOn: IntegrationTest
  condition: succeeded()
  jobs:
  - job: Push
    displayName: 'Push image'
    steps:
    # Download version info for pushing
    - download: current
      artifact: version-info
      displayName: 'Download version info'

    # Set Docker version variable for pushing
    - script: |
        source $(Pipeline.Workspace)/version-info/version.env
        echo "##vso[task.setvariable variable=DockerAppVersion]$APP_VERSION"
        echo "Pushing version: $APP_VERSION"
      displayName: 'Set Docker version variable'

    # Login to Docker Hub before pushing
    - task: Docker@2
      inputs:
        command: 'login'
        containerRegistry: 'docker-hub-connection'
      displayName: 'Login to Docker Hub'
    
    # Push Docker image to registry
    - task: Docker@2
      inputs:
        command: 'push'
        repository: '$(imageName)'
        tags: |
          $(DockerAppVersion)
          latest
      displayName: 'Push Docker image'

    # Create deployment information file
    - script: |
        source $(Pipeline.Workspace)/version-info/version.env
        echo "IMAGE_NAME=$(imageName)" > deployment-info.env
        echo "IMAGE_TAG=$APP_VERSION" >> deployment-info.env
        echo "FULL_VERSION=$FULL_VERSION" >> deployment-info.env
        echo "BUILD_DATE=$BUILD_DATE" >> deployment-info.env
        echo "PUSH_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> deployment-info.env
      displayName: 'Create deployment info'

    # Publish deployment info as artifact
    - publish: deployment-info.env
      artifact: deployment-info
      displayName: 'Publish deployment info'

# üßπ Cleanup stage - remove local images
- stage: Cleanup
  displayName: 'üßπ Cleanup'
  dependsOn: Push
  jobs:
  - job: Cleanup
    displayName: 'Cleanup'
    steps:
    # Download version info for cleanup
    - download: current
      artifact: version-info
      displayName: 'Download version info'

    # Remove Docker images to free up space
    - script: |
        source $(Pipeline.Workspace)/version-info/version.env
        docker rmi $(imageName):$APP_VERSION 2>/dev/null || true
        docker rmi $(imageName):latest 2>/dev/null || true
        docker image prune -f
      displayName: 'Remove images'
      condition: always()

# üìù Update Helm chart stage - update Kubernetes manifests
- stage: UpdateManifests
  displayName: 'üìù Update Helm Chart'
  dependsOn: Push
  jobs:
  - job: UpdateHelmChart
    displayName: 'Update Helm chart version'
    steps:
    # Checkout the k8s repository with manifests
    - checkout: k8s
      persistCredentials: true
      clean: true

    # Download version info for updating manifests
    - download: current
      artifact: version-info
      displayName: 'Download version info'

    # Update Helm chart values.yaml with new image version
    - script: |
        source $(Pipeline.Workspace)/version-info/version.env
        echo "Updating to version: $APP_VERSION"
        
        # Navigate to Helm chart directory
        cd todolist.v2/backend
        
        # Update image tag in values.yaml
        sed -i "s|tag:.*|tag: \"$APP_VERSION\"|g" values.yaml
        
        # Configure git user for committing changes
        git config user.email "azure-devops-pipeline@noreply.com"
        git config user.name "Azure DevOps Pipeline"
        
        # Commit and push the updated values.yaml
        git add values.yaml
        git commit -m "ci: update image tag to version $APP_VERSION" || echo "No changes to commit"
        git push origin main
        
        echo "‚úÖ Helm chart tag updated to: $APP_VERSION"
      displayName: 'Update Helm chart'
